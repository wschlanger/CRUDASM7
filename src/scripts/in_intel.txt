# Copyright (C) 2011 Willow Schlanger <wschlanger@gmail.com>.

#------------------------------------------------------------------------------------------------------------------------------

# This file (in_intel.txt) defines Intel x86/x64 instruction syntax and semantics. It is suitable for the construction of dis-
# assemblers and emulators, and other related tools.
#
# The following instructions are not implemented:
#
#   I have no plans to add the following instructions, as of this writing. This is because the instructions are so new, no one
#   seems to support them, and I believe they are AMD-only, though I'm not entirely sure. Even NASM doesn't support them.
#
#     andn            [Logical And-Not] [This is a BMI instruction]
#     bextr           [Bit Field Extract] [This is a BMI instruction]
#     blcfill         [Fill From Lowest Clear Bit] [This is a TBM instruction]
#     blci            [Isolate Lowest Clear Bit] [This is a TBM instruction]
#     blcic           [Isolate Lowest Set Bit and Complement] [This is a TBM instruction]
#     blcmsk          [Mask From Lowest Clear Bit] [This is a TBM instruction]
#     blcs            [Set Lowest Clear Bit] [This is a TBM instruction]
#     blsfill         [Fill From Lowest Set Bit] [This is a TBM instruction]
#     blsi            [Isolate Lowest Set Bit] [This is a TBM instruction]
#     blsic           [Isolate Lowest Set Bit and Complement] [This is a TBM instruction]
#     blsmsk          [Mask From Lowest Set Bit] [This is a TBM instruction]
#     blsr            [Reset Lowest Set Bit] [This is a TBM instruction]
#
#   The following instructions were found in the amd64 manual under general-purpose instructions, but I haven't verified Intel
#   supports them, nor do I think they are used very often, so I have left them as todo's:
#
#     clflush
#
# TO DO:
#
#   - add more instructions
#   - when syntax is being parsed:
#     - issue a warning if "known modes" introduces a duplicate mode name.
#     - set modes foo = (bar1, bar2, ...):
#       demand bar1, bar2, etc. are known modes at this point.
#       demand the mode 'foo' is undefined.
#     - xml:
#       <ix_modes>
#         <ix_mode_def def="mode:real" alias="false" />
#         <ix_mode_def def="mode:protected" alias="false" />
#         <ix_mode_def def="mode:all" alias="true">
#           <ix_mode_ref_list>
#             <ix_mode_ref ref="mode:real" />
#             <ix_mode_ref ref="mode:protected" />
#           </ix_mode_ref_list>
#       </ix_modes>
#     - parse groups. we will generate some xml eventually:
#       <ix_groups>
#         <ix_group def="group:decimal" title="Decimal Arithmetic Instructions" desc="The decimal arithmetic instructions perform decimal arithmetic..." />
#       </ix_groups>
#     - parse emu functions.
#       - make sure the "times" keyword argument has for terminal operands only
#         literal numbers, and the "sizeof" keyword. This permits unrolling
#         of loops at decode time if required. {For ENTER, we may need to use an imm arg in a loop.}
#         - note that sizeof() returns a B8 indicating the size of its argument in bytes. You can do
#           sizeof(P) or sizeof(Q); even sizeof(B4) but not sizeof(BIT). Also cannot do sizeof(x).
#       - introduce "axiom" keyword to refer to basic functions. they may be refered to by name,
#         or via prefix/infix notation. what about type casting? remember BIT and B<#>0> are reserved
#         words and cannot be used as an identifier.
#       - registers will need to be defined, so we can refer to them.
#     - parse instructions.
#       - This should be done after we've got a representative sample of instructions defined.
#
# NOTES:
#
#   - Literal numbers by themselves have a size of B8. For example, -1 means 0xffffffffffffffff.
#     Hexadecimal numbers' size is determined by the number of hex digits (size must be a multiple of 8 bits).
#     Hex numbers can have arbitrary size in bytes (any integer >= 1).
#     You can assign a literal number directly to an identifier; in this case, the literal is cast automatically
#     to the destination size, e.g. AX = 0 is the same as AX = B2(unsigned 0) where '0' is a B8. If 0 were
#     >= 65536 an error would have been generated.
#     When assigning a literal number to a BIT, the source is truncated to have BIT size, and an error is generated
#     if its value is not 0 or 1.
#     To create the 32-bit number 55, one can also do this: B4(unsigned 55). The 55 number is a B8
#   - Our <<, signed>>, unsigned>> operators take two arguments of equal sizes. If the 2nd argument is unsigned>=
#     the size of the first argument in bits, we get a 0 result. E.g. B2(unsigned 0xffff) >> B2(unsigned 16) yields
#     0x0000.

#------------------------------------------------------------------------------------------------------------------------------

# The x86 CPU has 6 modes of operation.
#
# real mode : this is the mode we're in when the CPU powers on.
# protected mode : same as real mode but cr0.pe=1 and rflags.vm=0
# vm86 mode : same as protected mode except we have rflags.vm=1 instead
# smm mode : same as real mode except it's initiated by an external pin;
#            in this mode, all segments have 4GB limits and are read-write.
#            the 'rsm' instruction is valid in this mode, and leaves smm.
#
# For the remaining two modes, you need to enable "long" mode. This is done
# by setting bit 8 (Long Mode Enable) of the EFER MSR via RDMSR / WRMSR.
# After long mode support has been enabled via MSRs, it is activated by entering
# protected mode and enabling paging hardware (bits 31 and 0 of CR0 respectively).
#
# pmode64 : this is long mode with cs.L=1 (enables 64bit mode).
# compat : this is long mode with cs.L=0. In this case, cs.D selects between
#          16bit and 32bit compatibility modes, just as it does in regular
#          protected mode.
known modes = (real, protected, vm86, smm, pmode64, compat);

# For the purpose of many instructions, real, smm, and vm86 modes behave the same.
# Note that some instructions are "sensitive" to rflags.vm, however.
set modes rmode = (real, smm, vm86);

# For the purpose of many instructions, protected and compatibility modes are the same.
set modes pmode = (protected, compat);

# Long mode is pmode64 or compat.
set modes long = (pmode64, compat);

# Legacy mode is any mode besides long mode.
set modes legacy = (real, protected, vm86, smm);

# Some instructions are valid in all modes.
set modes all = (legacy, long);

# Some instructions are valid in all modes except 64-bit mode.
set modes no64 = (rmode, pmode);

#------------------------------------------------------------------------------------------------------------------------------

groups begin
    group decimal [Decimal Arithmetic Instructions],
        [The decimal arithmetic instructions perform decimal arithmetic on binary coded decimal (BCD) data];
    group arith [Binary Arithmetic Instructions],
        [The binary arithmetic instructions perform basic binary integer computations on integers located in memory and/or the general purpose registers];
    group logical [Logical Instructions],
        [The logical instructions perform basic AND, OR, XOR, and NOT logical operations on byte, word, and doubleword values];
    group control [Control Transfer Instructions],
        [The control transfer instructions provide jump, conditional jump, loop, and call and return operations to control program flow];
    group bitbyte [Bit and Byte Instructions],
        [Bit instructions test and modify individual bits];
    group exchange [Exchange Instructions],
        [The exchange instructions swap the contents of one or more operands and, in some cases, perform additional operations];
    group control [Control Transfer Instructions],
        [Control-transfer instructions, or branches, are used to iterate through loops and move through conditional program logic];
    group data [Data Transfer Instructions],
        [The data transfer instructions move data between memory and the general-purpose and segment registers;],
        [they also perform specific operations such as conditional moves, stack access, and data conversion];
    group flagctrl [Flag Control Instructions],
        [The flag control instructions operate on the flags in the RFLAGS register];
end groups;

#------------------------------------------------------------------------------------------------------------------------------

insn aaa() begin
    group decimal;
    synopsis amd64 [ASCII Adjust After Addition];
    desc amd64 [Create an unpacked BCD number (invalid in 64-bit mode)];
    valid modes (no64);          # invalid opcode in 64-bit mode
    code 37 (void);
    emu begin
        AF = AF || ((AX & 0x000f) unsigned> 0x0009);
        CF = AF;
        AX = (AX + (AF ? 0x0106 : 0x0000)) & 0xff0f;
        OF = undefined 0;
        SF = undefined 0;
        ZF = undefined _zero(AL);
        PF = undefined _parity(AL);
    end emu;
    verified emu [10-14-2011];
end insn;

insn aad(B1 arg = 0x0a) begin
    group decimal;
    synopsis amd64 [ASCII Adjust Before Division];
    desc amd64 [Adjust two BCD digits in AL and AH (invalid in 64-bit mode)];
    valid modes (no64);          # invalid opcode in 64-bit mode
    notes [When assembling, the argument to AAD is optional; if missing, a default value of 0x0a is used.]
        [When disassembling, we print e.g. "aad 0x01" for d5 01, but print only "aad" for d5 0a.];
    code d5 (imm);
    dis begin
        write_insn_name();
        if (imm32 != 0x0000000a) begin
            write_space();
            write_args();
        end;
    end dis;
    emu begin
        AL = (AH * arg) + AL;
        AH = 0x00;
        SF = _sign(AL);
        ZF = _zero(AL);
        PF = _parity(AL);
        OF = undefined;
        AF = undefined;
        CF = undefined;
    end emu;
    verified emu [];
end insn;

insn aam(B1 arg = 0x0a) begin
    group decimal;
    synopsis amd64 [ASCII Adjust After Multiply];
    desc amd64 [Create a pair of unpacked BCD values in AH and AL (invalid in 64-bit mode)];
    valid modes (no64);          # invalid opcode in 64-bit mode
    notes [When assembling, the argument to AAM is optional; if missing, a default value of 0x0a is used.]
        [When disassembling, we print e.g. "aam 0x01" for d4 01, but print only "aam" for d4 0a.];
    code d4 (imm);
    dis begin
        write_insn_name();
        if (imm32 != 0x0000000a) begin
            write_space();
            write_args();
        end;
    end dis;
    emu begin
        except_assert(arg != 0x00, 0x00);
        B1 tmp = AL;
        AH = tmp unsigned/ arg;
        AL = tmp unsigned% arg;
        SF = _sign(AL);
        ZF = _zero(AL);
        PF = _parity(AL);
        OF = undefined;
        AF = undefined;
        CF = undefined;
    end emu;
    verified emu [];
end insn;

insn aas() begin
    group decimal;
    synopsis amd64 [ASCII Adjust After Subtraction];
    desc amd64 [Create an unpacked BCD number from the contents of the AL register (invalid in 64-bit mode)];
    valid modes (no64);          # invalid opcode in 64-bit mode
    code 3f (void);
    emu begin
        AF = AF || ((AX & 0x000f) unsigned> 0x0009);
        CF = AF;
        AX = (AX - (AF ? 0x0106 : 0x0000)) & 0xff0f;
        OF = undefined 0;
        SF = undefined 0;
        ZF = undefined _zero(AL);
        PF = undefined _parity(AL);
    end emu;
    verified emu [];
end insn;

# Functions with parameterized argument sizes are templates.

emu function bit _add_cf(P x, P y)
begin
    return (x + y) unsigned< x;
end;

emu function bit _sub_of(P x, P y)
begin
    BIT less = x unsigned< y;
    BIT sign = (x - y) signed< 0;
    return less != sign;
end;

emu function bit _sub_cf(P x, P y)
begin
    return x unsigned< y;
end;

emu function bit _add_of(P x, P y)
begin
    return ((y != 0) && ((y << 1) == 0)) || _sub_of(x, -y);
end;

emu function bit _adc_af(P x, P y, BIT c)
begin
    B1 aa = B1(x) & 0x0f;               # B1(x) returns x truncated to a size of one byte
    B1 bb = B1(y) & 0x0f;
    B1 cc = B1(unsigned c);             # This notation means we zero-extend the bit 'c' to a byte
    B1 d = (aa + bb) + cc;
    return d unsigned> 0x0f;
end;
		
emu function bit _adc_cf(P x, P y, BIT c)
begin
    P one = P(unsigned c);
    return _add_cf(x, y) | _add_cf(a + b, one);
end;

emu function bit _adc_of(P x, P y, BIT c)
begin
    P one = P(unsigned c);
	return _add_of(x, y) | _add_of(a + b, one);
end;

insn adc(P dest, P src) begin
    group arith;
    synopsis amd64 [Add with Carry];
    desc amd64 [Adds the carry flag (CF), the value in a register or memory location (first operand), and an immediate]
        [value or the value in a register or memory location (second operand), and stores the result in the first]
        [operand location];
    flags lockable;
    valid modes (all);
    code 80 /2 (reg/mem,imm) <P=B1>;
    code 82 /2 (reg/mem,imm) <P=B1, asm_skip>;    # asm_skip means, when assembling, don't encode this form -- it's an alias we want to avoid
    code 81 /2 (reg/mem,imm) <P=osz>;             # unless we use imm_disp64, if an imm arg is 64bits, it's sign-extended to 64bits from its encoded size (stored as 32 bits).
    code 83 /2 (reg/mem,imm) <P=osz, imm_sx8>;    # imm_sx8 means any imm args with a size of osz are really encoded as a byte
    code 10 /r (reg/mem,reg) <P=B1>;
    code 12 /r (reg,reg/mem) <P=B1>;
    code 11 /r (reg/mem,reg) <P=osz>;
    code 13 /r (reg,reg/mem) <P=osz>;
    code 14    (AL,imm) <P=B1>;
    code 15    (rAX,imm) <P=osz>;                 # rAX means AX, EAX, or RAX depending on the size of the argument (args have a type and size)
    emu begin
        BIT tmp = CF;
        OF = _adc_of(dest, src, tmp);
        AF = _adc_af(dest, src, tmp);
        CF = _adc_cf(dest, src, tmp);
        dest = (dest + src) + P(unsigned tmp);
        SF = _sign(dest);
        ZF = _zero(dest);
        PF = _parity(dest);
    end emu;
    verified emu [];
end insn;

insn add(P dest, P src) begin
    group arith;
    synopsis amd64 [Signed or Unsigned Add];
    desc amd64 [Adds the value in a register or memory location (first operand) and an immediate value or the value in]
        [a register or memory location (second operand), and stores the result in the first operand location];
    flags lockable;
    valid modes (all);
    code 80 /0 (reg/mem,imm) <P=B1>;
    code 82 /0 (reg/mem,imm) <P=B1, asm_skip>;    # asm_skip means, when assembling, don't encode this form -- it's an alias we want to avoid
    code 81 /0 (reg/mem,imm) <P=osz>;             # unless we use imm_disp64, if an imm arg is 64bits, it's sign-extended to 64bits from its encoded size (stored as 32 bits).
    code 83 /0 (reg/mem,imm) <P=osz, imm_sx8>;    # imm_sx8 means any imm args with a size of osz are really encoded as a byte
    code 00 /r (reg/mem,reg) <P=B1>;
    code 02 /r (reg,reg/mem) <P=B1>;
    code 01 /r (reg/mem,reg) <P=osz>;
    code 03 /r (reg,reg/mem) <P=osz>;
    code 04    (AL,imm) <P=B1>;
    code 05    (rAX,imm) <P=osz>;
    emu begin
        OF = _add_of(dest, src);
        AF = _add_af(dest, src);
        CF = _add_cf(dest, src);
        dest = dest + src;
        SF = _sign(dest);
        ZF = _zero(dest);
        PF = _parity(dest);
    end emu;
    verified emu [];
end insn;

insn and(P dest, P src) begin
    group logical;
    synopsis amd64 [Logical AND];
    desc amd64 [Performs a bitwise AND operation on the value in a register or memory location (first operand) and an]
        [immediate value or the value in a register or memory location (second operand), and stores the result]
        [in the first operand location];
    flags lockable;
    valid modes (all);
    code 80 /4 (reg/mem,imm) <P=B1>;
    code 82 /4 (reg/mem,imm) <P=B1, asm_skip>;    # asm_skip means, when assembling, don't encode this form -- it's an alias we want to avoid
    code 81 /4 (reg/mem,imm) <P=osz>;             # unless we use imm_disp64, if an imm arg is 64bits, it's sign-extended to 64bits from its encoded size (stored as 32 bits).
    code 83 /4 (reg/mem,imm) <P=osz, imm_sx8>;    # imm_sx8 means any imm args with a size of osz are really encoded as a byte
    code 20 /r (reg/mem,reg) <P=B1>;
    code 22 /r (reg,reg/mem) <P=B1>;
    code 21 /r (reg/mem,reg) <P=osz>;
    code 23 /r (reg,reg/mem) <P=osz>;
    code 24    (AL,imm) <P=B1>;
    code 25    (rAX,imm) <P=osz>;
    emu begin
        OF = 0;
		CF = 0;
        AF = undefined;
        dest = dest & src;
        SF = _sign(dest);
        ZF = _zero(dest);
        PF = _parity(dest);
    end emu;
    verified emu [];
end insn;

insn bound(P x, P y) begin
    group control;
    synopsis amd64 [Check Array Bound];
    desc amd64 [Checks whether an array index (first operand) is within the bounds of an array (second operand).]
    	[The array index is a signed integer in the specified register];
    valid modes (no64);          # invalid opcode in 64-bit mode
    code 62 /r /mod:mem_only (mem&mem) <P=osz>;
    emu begin
        except_assert((x unsigned>= low(y)) && (x unsigned<= high(y)), 0x05);     # BOUND range-exceeded exception is 0x05
    end emu;
    verified emu [];
end insn;

insn bsf(P dest, P src) begin
    group bitbyte;
    synopsis amd64 [Bit Scan Forward];
    desc amd64 [Searches the value in a register or a memory location (second operand) for the least-significant set bit];
    valid modes (all);
    code 0f bc /r (reg,reg/mem) <P=osz>;
    emu begin
        ZF = src == P(unsigned 0);
        BIT done = ZF;
        P tmp = src;
        P result = undefined(dest);
        times P i = (P(unsigned 8) * P(unsigned sizeof(P))) begin
            BIT tmp0 = (tmp & P(unsigned 1)) == P(unsigned 1);
            result = ((!done && tmp0) ? i : result);
            done = done || tmp0;
            tmp = tmp unsigned>> P(unsigned 1);
        end;

        # AMD says dest is UNCHANGED if src is 0, so that is what we will do here.
        # However, Intel says it's UNDEFINED in that case so we mark it as such if necessary !
        dest = result;
        
        # Undefined output flags.
        OF = undefined;
        SF = undefined;
        AF = undefined;
        PF = undefined;
        CF = undefined;
    end emu;
    verified emu [];
    notes [Destination argument is undefined on output if source argument is 0 according to Intel.]
    	[AMD reports the destination argument is left unmodified if source argument is 0.];
end insn;

insn bsr(P dest, P src) begin
    group bitbyte;
    synopsis amd64 [Bit Scan Reverse];
    desc amd64 [Searches the value in a register or a memory location (second operand) for the most-significant set bit];
    valid modes (all);
    code 0f bd /r (reg,reg/mem) <P=osz>;
    emu begin
        ZF = src == P(unsigned 0);
        BIT done = ZF;
        P tmp = src;
        P result = undefined(dest);
        P max = (P(unsigned 8) * P(unsigned sizeof(P)));
        times P i = max begin
            BIT tmp0 = _sign(tmp);
            result = ((!done && tmp0) ? max - i : result);
            done = done || tmp0;
            tmp = tmp << P(unsigned 1);
        end;

        # AMD says dest is UNCHANGED if src is 0, so that is what we will do here.
        # However, Intel says it's UNDEFINED in that case so we mark it as such if necessary !
        dest = result;
        
        # Undefined output flags.
        OF = undefined;
        SF = undefined;
        AF = undefined;
        PF = undefined;
        CF = undefined;
    end emu;
    verified emu [];
    notes [Destination argument is undefined on output if source argument is 0 according to Intel.]
    	[AMD reports the destination argument is left unmodified if source argument is 0.];
end insn;

insn bswap(P arg) begin
    group exchange;
    synopsis amd64 [Byte Swap];
    desc amd64 [Reverses the byte order of the specified register];
    valid modes (all);
    notes [Result is undefined if argument has a 16-bit size.]
    	[In this case, we treat the argument as if it were 32 bits in size.];
    code 0f c8 +r (reg) <P=osz(32,32,64)>;
    emu(osz) begin
    	osz(16): arg = undefined(combine4(bits(dest, 24, 8), bits(dest, 16, 8), bits(dest, 8, 8), bits(dest, 0, 8)));
    	osz(32): arg = combine4(bits(dest, 24, 8), bits(dest, 16, 8), bits(dest, 8, 8), bits(dest, 0, 8));
    	osz(64): arg = combine8(bits(dest, 56, 8), bits(dest, 48, 8), bits(dest, 40, 8), bits(dest, 32, 8),
    	    bits(dest, 24, 8), bits(dest, 16, 8), bits(dest, 8, 8), bits(dest, 0, 8)
        );
    end emu;
    verified emu [];
end insn;

# We need to look at the emu section of an insn to see if a memory argument is read from, written to, or both.
# We also need to determine HOW it is accessed. access_ea(x) just accesses the EA, itself [used by LEA]. We can
# also have an access offset: access_offset(x, <offset>) is possible. <offset> must not be a function of memory.

insn _bt_mem_reg(P x, P y) begin
    group bitbyte;
    synopsis amd64 [Bit Test];
    desc amd64 [Copies a bit, specified by a bit index in a register or 8-bit immediate value (second operand),]
    	[from a bit string (first operand), also called the bit base, to the carry flag (CF)];
    valid modes (all);
    asm names [bt];      # since there is only one entry here, this is the asm name to use when disassembling.
                         # if there are multiple names here, a 'dis' section must exist so we know what name to
                         # use when disassembling. if asm names is omitted, the default is one entry, whose name
                         # matches the instruction name.
                         # given 2 separate instructions (i.e. _bt_mem_reg & _bt_other), they can share a common
                         # asm name, such as "bt".
    code 0f a3 /r /mod:mem_only (mem,reg) <P=osz>;
    emu(osz) begin
        osz(16): B8 byte_offset = 0x0002 * (y unsigned/ 0x0010);
        osz(16): B2 bit_mask = B2(unsigned 1) << (y unsigned% 0x0010);
        osz(32): B8 byte_offset = 0x00000004 * (y unsigned/ 0x00000020);
        osz(32): B4 bit_mask = B4(unsigned 1) << (y unsigned% 0x00000020);
        osz(64): B8 byte_offset = 0x0000000000000008 * (y unsigned/ 0x0000000000000040);
        osz(64): B8 bit_mask = 0x0000000000000008 * (y unsigned% 0x0000000000000040);
        P tmp = access_offset(x, byte_offset);
        BIT result = (tmp & bit_mask) != P(unsigned 0);
        CF = result;
        OF = undefined;
        SF = undefined;
        ZF = undefined;
        AF = undefined;
        PF = undefined;
    end emu;
    verified emu [];
end insn;

insn _bt_other(P x, Q y) begin
    group bitbyte;
    synopsis amd64 [Bit Test];
    desc amd64 [Copies a bit, specified by a bit index in a register or 8-bit immediate value (second operand),]
    	[from a bit string (first operand), also called the bit base, to the carry flag (CF)];
    valid modes (all);
    asm names [bt];
    code 0f a3 /r /mod:reg_only (reg_rm,reg) <P=osz,Q=osz>;     # reg_rm: same as reg, but value comes from r/m part of mod:reg/op:r/m byte.
    code 0f ba /4 (reg/mem,imm) <P=osz,Q=B1>;
    emu(osz) begin
        osz(16): B2 index_masked = B2(unsigned y) & 0x000f;
        osz(16): B2 bit_mask = B2(unsigned 1) << index_masked;
        osz(32): B4 index_masked = B4(unsigned y) & 0x0000001f;
        osz(32): B4 bit_mask = B4(unsigned 1) << index_masked;
        osz(64): B8 index_masked = B8(unsigned y) & 0x000000000000003f;
        osz(64): B8 bit_mask = B8(unsigned 1) << index_masked;
        P tmp = x;
        BIT result = (tmp & bit_mask) != P(unsigned 0);
        CF = result;
        OF = undefined;
        SF = undefined;
        ZF = undefined;
        AF = undefined;
        PF = undefined;
    end emu;
    verified emu [];
end insn;

insn _btc_mem_reg(P x, P y) begin
    group bitbyte;
    synopsis amd64 [Bit Test and Complement];
    desc amd64 [Copies a bit, specified by a bit index in a register or 8-bit immediate value (second operand),]
        [from a bit string (first operand), also called the bit base, to the carry flag (CF)]
        [and then complement (toggle) the bit in the bit string];
    valid modes (all);
    flags lockable;
    asm names [btc];
    code 0f bb /r /mod:mem_only (mem,reg) <P=osz>;
    emu(osz) begin
        osz(16): B8 byte_offset = 0x0002 * (y unsigned/ 0x0010);
        osz(16): B2 bit_mask = B2(unsigned 1) << (y unsigned% 0x0010);
        osz(32): B8 byte_offset = 0x00000004 * (y unsigned/ 0x00000020);
        osz(32): B4 bit_mask = B4(unsigned 1) << (y unsigned% 0x00000020);
        osz(64): B8 byte_offset = 0x0000000000000008 * (y unsigned/ 0x0000000000000040);
        osz(64): B8 bit_mask = 0x0000000000000008 * (y unsigned% 0x0000000000000040);
        P tmp = access_offset(x, byte_offset);
        BIT result = (tmp & bit_mask) != P(unsigned 0);
        x = x ^ bit_mask;
        CF = result;
        OF = undefined;
        SF = undefined;
        ZF = undefined;
        AF = undefined;
        PF = undefined;
    end emu;
    verified emu [];
end insn;

insn _btc_other(P x, Q y) begin
    group bitbyte;
    synopsis amd64 [Bit Test and Complement];
    desc amd64 [Copies a bit, specified by a bit index in a register or 8-bit immediate value (second operand),]
        [from a bit string (first operand), also called the bit base, to the carry flag (CF)]
        [and then complement (toggle) the bit in the bit string];
    valid modes (all);
    flags lockable;
    asm names [btc];
    code 0f bb /r /mod:reg_only (reg_rm,reg) <P=osz,Q=osz>;     # reg_rm: same as reg, but value comes from r/m part of mod:reg/op:r/m byte.
    code 0f ba /7 (reg/mem,imm) <P=osz,Q=B1>;
    emu(osz) begin
        osz(16): B2 index_masked = B2(unsigned y) & 0x000f;
        osz(16): B2 bit_mask = B2(unsigned 1) << index_masked;
        osz(32): B4 index_masked = B4(unsigned y) & 0x0000001f;
        osz(32): B4 bit_mask = B4(unsigned 1) << index_masked;
        osz(64): B8 index_masked = B8(unsigned y) & 0x000000000000003f;
        osz(64): B8 bit_mask = B8(unsigned 1) << index_masked;
        P tmp = x;
        BIT result = (tmp & bit_mask) != P(unsigned 0);
        x = x ^ bit_mask;
        CF = result;
        OF = undefined;
        SF = undefined;
        ZF = undefined;
        AF = undefined;
        PF = undefined;
    end emu;
    verified emu [];
end insn;

insn _btr_mem_reg(P x, P y) begin
    group bitbyte;
    synopsis amd64 [Bit Test and Reset];
    desc amd64 [Copies a bit, specified by a bit index in a register or 8-bit immediate value (second operand),]
        [from a bit string (first operand), also called the bit base, to the carry flag (CF)]
        [and then clear the bit in the bit string to 0];
    valid modes (all);
    flags lockable;
    asm names [btr];
    code 0f b3 /r /mod:mem_only (mem,reg) <P=osz>;
    emu(osz) begin
        osz(16): B8 byte_offset = 0x0002 * (y unsigned/ 0x0010);
        osz(16): B2 bit_mask = B2(unsigned 1) << (y unsigned% 0x0010);
        osz(32): B8 byte_offset = 0x00000004 * (y unsigned/ 0x00000020);
        osz(32): B4 bit_mask = B4(unsigned 1) << (y unsigned% 0x00000020);
        osz(64): B8 byte_offset = 0x0000000000000008 * (y unsigned/ 0x0000000000000040);
        osz(64): B8 bit_mask = 0x0000000000000008 * (y unsigned% 0x0000000000000040);
        P tmp = access_offset(x, byte_offset);
        BIT result = (tmp & bit_mask) != P(unsigned 0);
        x = x & (~bit_mask);
        CF = result;
        OF = undefined;
        SF = undefined;
        ZF = undefined;
        AF = undefined;
        PF = undefined;
    end emu;
    verified emu [];
end insn;

insn _btr_other(P x, Q y) begin
    group bitbyte;
    synopsis amd64 [Bit Test and Reset];
    desc amd64 [Copies a bit, specified by a bit index in a register or 8-bit immediate value (second operand),]
        [from a bit string (first operand), also called the bit base, to the carry flag (CF)]
        [and then clear the bit in the bit string to 0];
    valid modes (all);
    flags lockable;
    asm names [btr];
    code 0f b3 /r /mod:reg_only (reg_rm,reg) <P=osz,Q=osz>;     # reg_rm: same as reg, but value comes from r/m part of mod:reg/op:r/m byte.
    code 0f ba /6 (reg/mem,imm) <P=osz,Q=B1>;
    emu(osz) begin
        osz(16): B2 index_masked = B2(unsigned y) & 0x000f;
        osz(16): B2 bit_mask = B2(unsigned 1) << index_masked;
        osz(32): B4 index_masked = B4(unsigned y) & 0x0000001f;
        osz(32): B4 bit_mask = B4(unsigned 1) << index_masked;
        osz(64): B8 index_masked = B8(unsigned y) & 0x000000000000003f;
        osz(64): B8 bit_mask = B8(unsigned 1) << index_masked;
        P tmp = x;
        BIT result = (tmp & bit_mask) != P(unsigned 0);
        x = x & (~bit_mask);
        CF = result;
        OF = undefined;
        SF = undefined;
        ZF = undefined;
        AF = undefined;
        PF = undefined;
    end emu;
    verified emu [];
end insn;

insn _bts_mem_reg(P x, P y) begin
    group bitbyte;
    synopsis amd64 [Bit Test and Set];
    desc amd64 [Copies a bit, specified by a bit index in a register or 8-bit immediate value (second operand),]
        [from a bit string (first operand), also called the bit base, to the carry flag (CF)]
        [and then set the bit in the bit string to 1];
    valid modes (all);
    flags lockable;
    asm names [bts];
    code 0f ab /r /mod:mem_only (mem,reg) <P=osz>;
    emu(osz) begin
        osz(16): B8 byte_offset = 0x0002 * (y unsigned/ 0x0010);
        osz(16): B2 bit_mask = B2(unsigned 1) << (y unsigned% 0x0010);
        osz(32): B8 byte_offset = 0x00000004 * (y unsigned/ 0x00000020);
        osz(32): B4 bit_mask = B4(unsigned 1) << (y unsigned% 0x00000020);
        osz(64): B8 byte_offset = 0x0000000000000008 * (y unsigned/ 0x0000000000000040);
        osz(64): B8 bit_mask = 0x0000000000000008 * (y unsigned% 0x0000000000000040);
        P tmp = access_offset(x, byte_offset);
        BIT result = (tmp & bit_mask) != P(unsigned 0);
        x = x | bit_mask;
        CF = result;
        OF = undefined;
        SF = undefined;
        ZF = undefined;
        AF = undefined;
        PF = undefined;
    end emu;
    verified emu [];
end insn;

insn _bts_other(P x, Q y) begin
    group bitbyte;
    synopsis amd64 [Bit Test and Set];
    desc amd64 [Copies a bit, specified by a bit index in a register or 8-bit immediate value (second operand),]
        [from a bit string (first operand), also called the bit base, to the carry flag (CF)]
        [and then set the bit in the bit string to 1];
    valid modes (all);
    flags lockable;
    asm names [bts];
    code 0f ab /r /mod:reg_only (reg_rm,reg) <P=osz,Q=osz>;     # reg_rm: same as reg, but value comes from r/m part of mod:reg/op:r/m byte.
    code 0f ba /5 (reg/mem,imm) <P=osz,Q=B1>;
    emu(osz) begin
        osz(16): B2 index_masked = B2(unsigned y) & 0x000f;
        osz(16): B2 bit_mask = B2(unsigned 1) << index_masked;
        osz(32): B4 index_masked = B4(unsigned y) & 0x0000001f;
        osz(32): B4 bit_mask = B4(unsigned 1) << index_masked;
        osz(64): B8 index_masked = B8(unsigned y) & 0x000000000000003f;
        osz(64): B8 bit_mask = B8(unsigned 1) << index_masked;
        P tmp = x;
        BIT result = (tmp & bit_mask) != P(unsigned 0);
        x = x | bit_mask;
        CF = result;
        OF = undefined;
        SF = undefined;
        ZF = undefined;
        AF = undefined;
        PF = undefined;
    end emu;
    verified emu [];
end insn;

# Some more insn flags.
# - has_cc
#   low 4 bits of basecode is a condition code.
#   the pseudo-variable "_cc" is a BIT that is 0 or 1 according to whether or not the condition is met.
#   Prior to instruction execution we add a line such as BIT _cc = cond_nbe(CF, ZF).
# - ctrlxfer
#   This indicates the instruction writes to one of these:
#   - RIP_ADD, RIP_SET
#     Default values:
#     - RIP_SET = in.RIP + insn.length
#     - RIP_ADD = 0
#     When the instruction completes we will set RIP to (RIP_SET + RIP_ADD) & RIP_MASK where the latter
#     is determined by the opcode size; in 64bit mode, RIP_MASK is 0xffffffffffffffff unless op66 was used
#     without rex.w (right? if rex.w is used don't we ignore opcode 0x66?) in which case it is 0xffff.
# - stack
#   This indicates the instruction contains at least one push or pop.
#   Special considerations:
#   - the flag "default64" means that by default in 64bit mode, the operand size (osz) is 64 bits. you can
#     then use 0x66 to change it to 16bits, but there is no way to change it to 32 bits; presumably, rex.w
#     is ignored here.
#   - enter, leave
#   - how to access the stack?
#     push x;
#     pop x;
#     When in 64bit mode, presumably, RSP is always used for stack accesses. Otherwise, ss.d_b determines
#     whether to use SP or ESP.
#     'x' should have a size corresponding to osz. For some instructions osz is either 64bits or 16bits when
#     in 64bit mode.
#   - During the first pass through emu code, we take care of memory accesses -- where are they? Read/write?
#     Whenever a PUSH or POP is done, we must know the input rSP as a function of the input rSP & rBP.
#     Ex.:
#     Some insn [leave] may do this:
#       rSP = rBP;   # rSP/rBP size is determined by ss.d_b
#       osz(16): pop BP;
#       ...
#     Here, we know we're pop'ing to BP/EBP/RBP (depending on osz) from [ss:in.rBP].
#     The above behavior may be inexact; maybe db 0x66 / leave in 32-bit mode really does this:
#       mov sp,bp
#       pop bp
#     we on the other hand would do this:
#       mov esp,ebp
#       pop bp
#     in that case.
#
# More thoughts:
# - how will we handle REP/REPcond ?
#   There are repable and repcond flags.
#   To repeat an instruction, we can do RIP_SET = RIP_CUR. Repeated instructions should be marked "ctrlxfer."
#   - From an assembler perspective, _movsb and _rep_movsb are two different instructions. Note that f2/f3/f0
#     are handled specially, so f2 f3 64 (movsb) is matches f3 (movsb) -- we demand prefixes be present, but
#     not necesarilly in the same order. We will use f2 & f3 encodings, with one being marked asm_skip.

insn _call(P x) begin
    group control;
    asm names [call];
    synopsis amd64 [Near Procedure Call];
    desc amd64 [Pushes the offset of the next instruction onto the stack and branches to the target address];
    valid modes (all);
    flags ctrlxfer, default64;               # in 64bit mode, osz defaults to 64bits; use 0x66 for 16 bits; no encoding for 32 bits.
    code e8 (imm) <P=osz,imm_rel_branch>;    # imm arg with osz as size is a RELATIVE BRANCH TARGET. sx'd to 64bits in osz=64 bits mode.
                                             # when we disassemble, relative branch targets have the insn length and decode offset added
                                             # for disassembly purposes only. For emulation purposes, we get the relative value itself.
                                             # ex.: JMP SHORT $  -> eb fe  -> in 64 bit mode, the argument is 0xfffffffffffffffe.
    emu(osz) begin
        push rIP;                            # the size of rIP is determined by the operand size.
                                             # above expands into:
                                             # osz(16): push IP;
                                             # osz(32): push EIP;
                                             # osz(64): push RIP;
        osz(16): RIP_ADD = B8(unsigned x);
        osz(32): RIP_ADD = B8(unsigned x);
        osz(64): RIP_ADD = x;
    end emu;
    verified emu [];
end insn;

insn _calli(P x) begin
    group control;
    asm names [call];
    synopsis amd64 [Near Procedure Call];
    desc amd64 [Pushes the offset of the next instruction onto the stack and branches to the target address];
    valid modes (all);
    flags ctrlxfer, default64;               # in 64bit mode, osz defaults to 64bits; use 0x66 for 16 bits; no encoding for 32 bits.
    code ff /2 (reg/mem) <P=osz>;
    emu(osz) begin
        push rIP;                            # the size of rIP is determined by the operand size.
                                             # above expands into:
                                             # osz(16): push IP;
                                             # osz(32): push EIP;
                                             # osz(64): push RIP;
        osz(16): RIP_SET = B8(unsigned x);
        osz(32): RIP_SET = B8(unsigned x);
        osz(64): RIP_SET = x;
    end emu;
    verified emu [];
end insn;

insn _callfd(P xofs, B2 xseg) begin
    group control;
    asm names [call];
    synopsis amd64 [Far Procedure Call];
    desc amd64 [Pushes procedure linking information onto the stack and branches to the target address, which contains]
        [the first instruction of the called procedure.];
    valid modes (all);
    flags ctrlxfer, default64;               # in 64bit mode, osz defaults to 64bits; use 0x66 for 16 bits; no encoding for 32 bits.
    code 9a (imm,imm) <P=osz,no64>;
    emu(osz) begin
        push P(unsigned CS);                 # push CS, zero-extended to operand size
        push rIP;                            # the size of rIP is determined by the operand size.
                                             # above expands into:
                                             # osz(16): push IP;
                                             # osz(32): push EIP;
                                             # osz(64): push RIP;
        CS = xseg;
        osz(16): RIP_SET = B8(unsigned xofs);
        osz(32): RIP_SET = B8(unsigned xofs);
        osz(64): RIP_SET = xofs;
    end emu;
    verified emu [];
    dis begin
        write_insn_name();
        write_space();
        write_far_imm();
    end dis;
end insn;

insn _callfi(P x) begin
    group control;
    asm names [call];
    synopsis amd64 [Far Procedure Call];
    desc amd64 [Pushes procedure linking information onto the stack and branches to the target address, which contains]
        [the first instruction of the called procedure.];
    valid modes (all);
    flags ctrlxfer, ignore_rex_w;            # amd64 says "target offset can only be a 16- or 32-bit value"; offset is zero-extended to 64 bits.
    code ff /3 /mod:mem_only (mem) <P=osz>;
    emu(osz) begin
        push P(unsigned CS);                 # push CS, zero-extended to operand size
        push rIP;                            # the size of rIP is determined by the operand size.
                                             # above expands into:
                                             # osz(16): push IP;
                                             # osz(32): push EIP;
                                             # osz(64): push RIP;
        CS = seg(x);
        osz(16): RIP_SET = B8(unsigned ofs(x));
        osz(32): RIP_SET = B8(unsigned ofs(x));
        osz(64): RIP_SET = ofs(x);           # this cannot happen since we ignore rex.w, but is here for completeness.
    end emu;
    verified emu [];
end insn;

#------------------------------------------------------------------------------------------------------------------------------

# sign-extend accumulator.
insn _sxacc() begin
    group data;
    asm names [cbw], [cwde], [cdqe];
    synopsis amd64 [Convert to Sign-Extended];
    desc amd64 [Copies the sign bit in the AL or eAX register to the upper bits of the rAX register];
    valid modes (all);
    code 98 (void);
    emu(osz) begin
        osz(16): AX = B2(signed AL);
        osz(32): EAX = B4(signed AX);
        osz(64): RAX = B8(signed EAX);
    end emu;
    verified emu [];
end insn;

# sign-extend to rDX:rAX ("dax").
insn _sxdax() begin
    group data;
    asm names [cwd], [cdq], [cqo];
    synopsis amd64 [Convert to Sign-Extended];
    desc amd64 [Copies the sign bit in the rAX register to all bits of the rDX register];
    valid modes (all);
    code 99 (void);
    emu(osz) begin
        osz(16): DX = (_sign(AX) ? 0xffff : 0x0000);
        osz(32): EDX = (_sign(EAX) ? 0xffffffff : 0x00000000);
        osz(64): RDX = (_sign(EAX) ? 0xffffffffffffffff : 0x0000000000000000);
    end emu;
    verified emu [];
end insn;

insn clc() begin
    group flagctrl;
    synopsis amd64 [Clear Carry Flag];
    desc amd64 [Clears the carry flag (CF) in the rFLAGS register to zero];
    valid modes (all);
    code f8 (void);
    emu begin
        CF = 0;
    end emu;
    verified emu [];
end insn;

insn cld() begin
    group flagctrl;
    synopsis amd64 [Clear Direction Flag];
    desc amd64 [Clears the direction flag (DF) in the rFLAGS register to zero];
    valid modes (all);
    code fc (void);
    emu begin
        DF = 0;
    end emu;
    verified emu [];
end insn;

# [+] todo: clflush

insn cmc() begin
    group flagctrl;
    synopsis amd64 [Complement Direction Flag];
    desc amd64 [Complements (toggles) the carry flag (CF) bit of the rFLAGS register];
    valid modes (all);
    code f5 (void);
    emu begin
        CF = !CF;
    end emu;
    verified emu [];
end insn;
